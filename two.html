<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Polar H10 HRV Monitor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }
    #dataTable {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    #dataTable th, #dataTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    #dataTable th {
      background-color: #f2f2f2;
    }
    .flex-buttons {
      margin-bottom: 10px;
    }
    .status {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
    .baseline-box {
      margin-top: 15px;
      font-size: 14px;
      background-color: #f9f9f9;
      padding: 10px;
      border: 1px solid #ddd;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>Polar H10 HRV Monitor</h1>

  <div class="flex-buttons">
    <button id="connectButton">Polar H10 と接続</button>
    <button id="startButton" disabled>計測開始</button>
    <button id="stopButton" disabled>計測停止</button>
    <button id="resetButton">リセット</button>
    <button id="downloadButton" disabled>CSVダウンロード</button>
  </div>
  
  <div class="status" id="status">未接続</div>
  <div class="baseline-box" id="baselineBox" style="display: none;">
    <strong>ベースライン（開始5分間の平均）</strong><br>
    BPM: <span id="baselineBpm">-</span><br>
    SDNN: <span id="baselineSdnn">-</span><br>
    RMSSD: <span id="baselineRmssd">-</span><br>
    LF/HF: <span id="baselineLfHf">-</span>
  </div>

  <table id="dataTable">
    <thead>
      <tr>
        <th>日時</th>
        <th>経過時間(分:秒)</th>
        <th>BPM</th>
        <th>SDNN (ms)</th>
        <th>RMSSD (ms)</th>
        <th>LF/HF</th>
      </tr>
    </thead>
    <tbody id="dataBody">
      <!-- 最新のデータを上に表示 -->
    </tbody>
  </table>

  <script>
    // ====================================
    // グローバル変数
    // ====================================
    let heartRateCharacteristic = null;
    let device = null;

    // RR間隔(ms)を蓄積(最新300件など適度に制限)
    const rrIntervalBuffer = [];

    // 表示するデータを蓄積
    // { dateTime, elapsed, bpm, sdnn, rmssd, lfHf }
    let dataRecords = [];

    // 開始時刻(計測開始ボタンを押した時)
    let measurementStartTime = null;

    // 計測中フラグ
    let isMeasuring = false;

    // ベースライン計算用
    let baselineRecords = [];  // 計測開始から5分間のデータを保存
    let baselineCalculated = false; // 5分経過後に一度だけ計算する
    const BASELINE_DURATION_MS = 5 * 60 * 1000; // 5分

    // 要素の取得
    const statusElem = document.getElementById('status');
    const dataBody = document.getElementById('dataBody');
    const connectButton = document.getElementById('connectButton');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const resetButton = document.getElementById('resetButton');
    const downloadButton = document.getElementById('downloadButton');
    const baselineBox = document.getElementById('baselineBox');
    const baselineBpmElem = document.getElementById('baselineBpm');
    const baselineSdnnElem = document.getElementById('baselineSdnn');
    const baselineRmssdElem = document.getElementById('baselineRmssd');
    const baselineLfHfElem = document.getElementById('baselineLfHf');

    // ====================================
    // 1. Polar H10 との接続処理
    // ====================================
    connectButton.addEventListener('click', async () => {
      try {
        statusElem.textContent = 'デバイス選択ダイアログを開いています...';
        device = await navigator.bluetooth.requestDevice({
          filters: [{ services: ['heart_rate'] }]
        });
        statusElem.textContent = 'デバイスに接続中...';
        const server = await device.gatt.connect();
        const service = await server.getPrimaryService('heart_rate');
        heartRateCharacteristic = await service.getCharacteristic('heart_rate_measurement');

        await heartRateCharacteristic.startNotifications();
        heartRateCharacteristic.addEventListener('characteristicvaluechanged', handleHeartRateMeasurement);

        statusElem.textContent = '接続しました。計測の準備ができます。';
        connectButton.disabled = true;
        startButton.disabled = false;
        stopButton.disabled = false;
      } catch (error) {
        console.error(error);
        statusElem.textContent = '接続エラー: ' + error;
      }
    });

    // ====================================
    // 2. 計測開始ボタン
    // ====================================
    startButton.addEventListener('click', () => {
      if (!heartRateCharacteristic) {
        alert('まず「Polar H10 と接続」してください。');
        return;
      }
      // 計測フラグを立てる
      isMeasuring = true;
      // 計測開始時刻を記憶
      measurementStartTime = new Date();
      // ベースライン計算用を初期化
      baselineRecords = [];
      baselineCalculated = false;
      statusElem.textContent = '計測を開始しました。';

      // ダウンロードボタン有効化（初回データが入ったら有効になる想定）
      downloadButton.disabled = true;
    });

    // ====================================
    // 3. 計測停止ボタン
    // ====================================
    stopButton.addEventListener('click', () => {
      if (!heartRateCharacteristic) {
        alert('まず「Polar H10 と接続」してください。');
        return;
      }
      isMeasuring = false;
      statusElem.textContent = '計測を停止しました。';
    });

    // ====================================
    // 4. リセットボタン
    // ====================================
    resetButton.addEventListener('click', () => {
      // すべてリセット
      isMeasuring = false;
      measurementStartTime = null;
      rrIntervalBuffer.length = 0;
      dataRecords = [];
      baselineRecords = [];
      baselineCalculated = false;
      baselineBox.style.display = 'none';

      // テーブルを初期化
      dataBody.innerHTML = '';

      // 状態表示を初期化
      statusElem.textContent = 'リセットしました。（接続が必要なら再度お願いします）';

      // ボタンなどの状態
      downloadButton.disabled = true;
    });

    // ====================================
    // 5. 心拍センサー通知の受信処理
    // ====================================
    function handleHeartRateMeasurement(event) {
      // 計測中でなければ処理しない
      if (!isMeasuring) return;

      const value = event.target.value;
      const flags = value.getUint8(0);
      const is16BitHR = flags & 0x1;
      let bpm;
      let index = 1;

      if (is16BitHR) {
        bpm = value.getUint16(index, true);
        index += 2;
      } else {
        bpm = value.getUint8(index);
        index += 1;
      }

      // RR間隔のフラグ(0x10)が立っている場合のみ
      const rrFlag = flags & 0x10;
      let rrIntervals = [];
      if (rrFlag) {
        // 残りのデータを RR-Interval としてパース(単位: 1/1024 s)
        for (; index < value.byteLength; index += 2) {
          const rr = value.getUint16(index, true);
          // ms単位
          rrIntervals.push(rr * 1000.0 / 1024.0);
        }
      }

      // バッファ追加（大きくなり過ぎないよう制限）
      rrIntervals.forEach(rr => rrIntervalBuffer.push(rr));
      if (rrIntervalBuffer.length > 300) {
        rrIntervalBuffer.splice(0, rrIntervalBuffer.length - 300);
      }

      // HRV 指標を計算
      const { sdnn, rmssd } = calculateTimeDomainHRV(rrIntervalBuffer);
      const lfHf = calculateLFHFRatio(rrIntervalBuffer);

      // 日時
      const now = new Date();
      const dateTimeString = formatDateTime(now); // yyyy/MM/dd HH:mm:ss

      // 経過時間(分:秒)
      const elapsedMs = now - measurementStartTime;
      const elapsedStr = formatElapsedTime(elapsedMs);

      // 新しい行データ
      const newRowData = {
        dateTime: dateTimeString,
        elapsed: elapsedStr,
        bpm: bpm.toFixed(0),
        sdnn: sdnn.toFixed(2),
        rmssd: rmssd.toFixed(2),
        lfHf: lfHf.toFixed(2)
      };

      // テーブル更新
      dataRecords.push(newRowData);
      prependTableRow(newRowData);

      // ベースライン計算用に5分以内であれば蓄積
      if (!baselineCalculated && elapsedMs <= BASELINE_DURATION_MS) {
        baselineRecords.push({
          bpm: bpm,
          sdnn: sdnn,
          rmssd: rmssd,
          lfHf: lfHf
        });
      }
      // 5分経過していて、まだベースライン未計算なら平均を出す
      if (!baselineCalculated && elapsedMs > BASELINE_DURATION_MS) {
        calculateBaseline();
        baselineCalculated = true;
      }

      // データが1つ以上あるならダウンロードボタン活性
      downloadButton.disabled = dataRecords.length === 0;
    }

    // ====================================
    // 6. テーブルの先頭に行を追加
    // ====================================
    function prependTableRow(rowData) {
      const newRow = document.createElement('tr');

      const dateTimeCell = document.createElement('td');
      dateTimeCell.textContent = rowData.dateTime;

      const elapsedCell = document.createElement('td');
      elapsedCell.textContent = rowData.elapsed;

      const bpmCell = document.createElement('td');
      bpmCell.textContent = rowData.bpm;

      const sdnnCell = document.createElement('td');
      sdnnCell.textContent = rowData.sdnn;

      const rmssdCell = document.createElement('td');
      rmssdCell.textContent = rowData.rmssd;

      const lfHfCell = document.createElement('td');
      lfHfCell.textContent = rowData.lfHf;

      newRow.appendChild(dateTimeCell);
      newRow.appendChild(elapsedCell);
      newRow.appendChild(bpmCell);
      newRow.appendChild(sdnnCell);
      newRow.appendChild(rmssdCell);
      newRow.appendChild(lfHfCell);

      if (dataBody.firstChild) {
        dataBody.insertBefore(newRow, dataBody.firstChild);
      } else {
        dataBody.appendChild(newRow);
      }
    }

    // ====================================
    // 7. Time Domain (SDNN, RMSSD) 計算
    // ====================================
    function calculateTimeDomainHRV(rrArray) {
      if (rrArray.length < 2) {
        return { sdnn: 0, rmssd: 0 };
      }
      // 平均
      const avg = rrArray.reduce((a, b) => a + b, 0) / rrArray.length;
      // SDNN = RR間隔の標準偏差
      const variance = rrArray.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / rrArray.length;
      const sdnn = Math.sqrt(variance);

      // RMSSD = 連続するRR間隔の差分の二乗平均平方根
      let sumSqDiff = 0;
      for (let i = 1; i < rrArray.length; i++) {
        const diff = rrArray[i] - rrArray[i - 1];
        sumSqDiff += diff * diff;
      }
      const meanSqDiff = sumSqDiff / (rrArray.length - 1);
      const rmssd = Math.sqrt(meanSqDiff);

      return { sdnn, rmssd };
    }

    // ====================================
    // 8. Frequency Domain (LF/HF) の簡易計算
    // ====================================
    function calculateLFHFRatio(rrArray) {
      if (rrArray.length < 4) {
        return 0;
      }

      // 時間列を作る
      const timeStamps = [0];
      for (let i = 1; i < rrArray.length; i++) {
        timeStamps.push(timeStamps[i - 1] + rrArray[i - 1] / 1000.0);
      }

      // サンプリング周波数
      const fs = 4; // 4Hz=250ms
      const dt = 1.0 / fs;
      const totalDuration = timeStamps[timeStamps.length - 1];
      const resampledCount = Math.floor(totalDuration * fs);
      if (resampledCount < 4) return 0;

      const resampledRR = [];
      let currentIndex = 0;
      for (let n = 0; n < resampledCount; n++) {
        const t = n * dt;
        while (currentIndex < timeStamps.length - 1 && timeStamps[currentIndex + 1] < t) {
          currentIndex++;
        }
        if (currentIndex >= timeStamps.length - 1) {
          break;
        }
        const t1 = timeStamps[currentIndex];
        const t2 = timeStamps[currentIndex + 1];
        const rr1 = rrArray[currentIndex];
        const rr2 = rrArray[currentIndex + 1];
        if (t2 === t1) {
          resampledRR.push(rr1);
        } else {
          const ratio = (t - t1) / (t2 - t1);
          const rrInterp = rr1 + (rr2 - rr1) * ratio;
          resampledRR.push(rrInterp);
        }
      }

      // DFT (簡易実装)
      const N = resampledRR.length;
      if (N < 4) return 0;
      const re = new Array(N).fill(0);
      const im = new Array(N).fill(0);

      for (let k = 0; k < N; k++) {
        for (let n = 0; n < N; n++) {
          const angle = (2 * Math.PI * k * n) / N;
          re[k] += resampledRR[n] * Math.cos(angle);
          im[k] -= resampledRR[n] * Math.sin(angle);
        }
      }

      // スペクトルパワー
      const freqs = [];
      const psd = [];
      for (let k = 0; k < N; k++) {
        const freq = (k * fs) / N;
        const magnitude = (re[k] * re[k] + im[k] * im[k]) / N;
        freqs.push(freq);
        psd.push(magnitude);
      }

      // LF(0.04-0.15Hz), HF(0.15-0.4Hz)
      let lfPower = 0;
      let hfPower = 0;
      for (let k = 0; k < N; k++) {
        const f = freqs[k];
        if (f >= 0.04 && f < 0.15) {
          lfPower += psd[k];
        } else if (f >= 0.15 && f < 0.4) {
          hfPower += psd[k];
        }
      }
      const lfHfRatio = hfPower === 0 ? 0 : lfPower / hfPower;
      return lfHfRatio;
    }

    // ====================================
    // 9. ベースラインの平均計算
    // ====================================
    function calculateBaseline() {
      if (baselineRecords.length === 0) {
        return;
      }
      // 各指標の単純平均
      const sumBpm = baselineRecords.reduce((acc, val) => acc + val.bpm, 0);
      const sumSdnn = baselineRecords.reduce((acc, val) => acc + val.sdnn, 0);
      const sumRmssd = baselineRecords.reduce((acc, val) => acc + val.rmssd, 0);
      const sumLfHf = baselineRecords.reduce((acc, val) => acc + val.lfHf, 0);

      const count = baselineRecords.length;
      const avgBpm = sumBpm / count;
      const avgSdnn = sumSdnn / count;
      const avgRmssd = sumRmssd / count;
      const avgLfHf = sumLfHf / count;

      // 表示
      baselineBox.style.display = 'inline-block';
      baselineBpmElem.textContent = avgBpm.toFixed(2);
      baselineSdnnElem.textContent = avgSdnn.toFixed(2);
      baselineRmssdElem.textContent = avgRmssd.toFixed(2);
      baselineLfHfElem.textContent = avgLfHf.toFixed(2);
    }

    // ====================================
    // 10. CSVダウンロード
    // ====================================
    downloadButton.addEventListener('click', () => {
      // ヘッダ行
      let csvContent = '日時,経過時間(分:秒),BPM,SDNN (ms),RMSSD (ms),LF/HF\n';
      dataRecords.forEach(record => {
        csvContent += `${record.dateTime},${record.elapsed},${record.bpm},${record.sdnn},${record.rmssd},${record.lfHf}\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      // ファイル名に日時を入れる
      const now = new Date();
      const fileNameDate = formatDateTimeForFileName(now); // 例: '20250101_123456'
      const fileName = `${fileNameDate}_PolarH10-HRV.csv`;

      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    // ====================================
    // 便利関数: 日時フォーマット
    // ====================================
    function formatDateTime(date) {
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const dd = String(date.getDate()).padStart(2, '0');
      const hh = String(date.getHours()).padStart(2, '0');
      const min = String(date.getMinutes()).padStart(2, '0');
      const sec = String(date.getSeconds()).padStart(2, '0');
      return `${yyyy}/${mm}/${dd} ${hh}:${min}:${sec}`;
    }

    function formatDateTimeForFileName(date) {
      // 例: 20250101_123456
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const dd = String(date.getDate()).padStart(2, '0');
      const hh = String(date.getHours()).padStart(2, '0');
      const min = String(date.getMinutes()).padStart(2, '0');
      const sec = String(date.getSeconds()).padStart(2, '0');
      return `${yyyy}${mm}${dd}_${hh}${min}${sec}`;
    }

    // 経過時間を分:秒形式に変換
    function formatElapsedTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return `${min}:${String(sec).padStart(2, '0')}`;
    }
  </script>
</body>
</html>
