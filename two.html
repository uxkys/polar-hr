<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Polar H10 HRV Monitor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    button {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
    }
    #dataTable {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    #dataTable th, #dataTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    #dataTable th {
      background-color: #f2f2f2;
    }
    .flex-buttons {
      margin-bottom: 10px;
    }
    .status {
      margin-top: 10px;
      font-size: 14px;
      color: #555;
    }
  </style>
</head>
<body>
  <h1>Polar H10 HRV Monitor</h1>
  <div class="flex-buttons">
    <button id="connectButton">Polar H10 と接続</button>
    <button id="downloadButton" disabled>CSVダウンロード</button>
  </div>
  <div class="status" id="status">未接続</div>
  <table id="dataTable">
    <thead>
      <tr>
        <th>時刻</th>
        <th>BPM</th>
        <th>SDNN (ms)</th>
        <th>RMSSD (ms)</th>
        <th>LF/HF</th>
      </tr>
    </thead>
    <tbody id="dataBody">
      <!-- 最新のデータを上に表示 -->
    </tbody>
  </table>

  <script>
    // ====================================
    // グローバル変数
    // ====================================
    let heartRateCharacteristic = null;
    // RR間隔をミリ秒で蓄積(最新200件など適度に制限)
    const rrIntervalBuffer = [];
    // 表示するデータ(時刻, BPM, SDNN, RMSSD, LF/HF)を蓄積
    const dataRecords = [];

    const statusElem = document.getElementById('status');
    const dataBody = document.getElementById('dataBody');
    const connectButton = document.getElementById('connectButton');
    const downloadButton = document.getElementById('downloadButton');

    // ====================================
    // Polar H10との接続処理
    // ====================================
    connectButton.addEventListener('click', async () => {
      try {
        statusElem.textContent = 'デバイス選択ダイアログを開いています...';
        // Polar H10 は標準の Heart Rate Service (UUID: 0x180D) を提供
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: ['heart_rate'] }]
        });

        statusElem.textContent = 'デバイスに接続中...';
        const server = await device.gatt.connect();

        // Heart Rate Service を取得
        const service = await server.getPrimaryService('heart_rate');
        // Heart Rate Measurement Characteristic (UUID: 0x2A37)
        heartRateCharacteristic = await service.getCharacteristic('heart_rate_measurement');

        // 通知を受け取る
        await heartRateCharacteristic.startNotifications();
        heartRateCharacteristic.addEventListener('characteristicvaluechanged', handleHeartRateMeasurement);

        statusElem.textContent = '接続しました。計測中...';
        connectButton.disabled = true;
      } catch (error) {
        console.error(error);
        statusElem.textContent = '接続エラー: ' + error;
      }
    });

    // ====================================
    // Heart Rate Measurement 通知時の処理
    // ====================================
    function handleHeartRateMeasurement(event) {
      const value = event.target.value;
      // DataView から各種データをパース
      const flags = value.getUint8(0);
      const is16BitHR = flags & 0x1;
      let bpm;
      let index = 1;

      if (is16BitHR) {
        bpm = value.getUint16(index, true);
        index += 2;
      } else {
        bpm = value.getUint8(index);
        index += 1;
      }

      // RR間隔のフラグ(0x10)が立っている場合のみ
      const rrFlag = flags & 0x10;
      let rrIntervals = [];
      if (rrFlag) {
        // 残りのデータを RR-Interval としてパース(単位: 1/1024 s)
        for (; index < value.byteLength; index += 2) {
          const rr = value.getUint16(index, true);
          // ms単位に変換
          rrIntervals.push(rr * 1000.0 / 1024.0);
        }
      }

      // 取得したRR間隔をグローバルバッファに格納
      rrIntervals.forEach(rr => {
        rrIntervalBuffer.push(rr);
      });
      // バッファが大きくなりすぎないように先頭を切り捨て(例: 300件まで)
      if (rrIntervalBuffer.length > 300) {
        rrIntervalBuffer.splice(0, rrIntervalBuffer.length - 300);
      }

      // ここで HRV 指標を計算
      const { sdnn, rmssd } = calculateTimeDomainHRV(rrIntervalBuffer);
      const lfHf = calculateLFHFRatio(rrIntervalBuffer);

      // テーブルの先頭に新しい行を追加する
      const timeString = new Date().toLocaleTimeString();
      const newRowData = {
        time: timeString,
        bpm: bpm.toFixed(0),
        sdnn: sdnn.toFixed(2),
        rmssd: rmssd.toFixed(2),
        lfHf: lfHf.toFixed(2)
      };
      dataRecords.push(newRowData);

      // 表示を更新
      prependTableRow(newRowData);
      // CSV ダウンロードボタンを有効にする
      downloadButton.disabled = false;
    }

    // ====================================
    // テーブルに上から行を追加する
    // ====================================
    function prependTableRow(rowData) {
      const newRow = document.createElement('tr');

      const timeCell = document.createElement('td');
      timeCell.textContent = rowData.time;
      const bpmCell = document.createElement('td');
      bpmCell.textContent = rowData.bpm;
      const sdnnCell = document.createElement('td');
      sdnnCell.textContent = rowData.sdnn;
      const rmssdCell = document.createElement('td');
      rmssdCell.textContent = rowData.rmssd;
      const lfHfCell = document.createElement('td');
      lfHfCell.textContent = rowData.lfHf;

      newRow.appendChild(timeCell);
      newRow.appendChild(bpmCell);
      newRow.appendChild(sdnnCell);
      newRow.appendChild(rmssdCell);
      newRow.appendChild(lfHfCell);

      // 最新のデータを「上に」表示するため、tbodyの先頭に挿入
      if (dataBody.firstChild) {
        dataBody.insertBefore(newRow, dataBody.firstChild);
      } else {
        dataBody.appendChild(newRow);
      }
    }

    // ====================================
    // Time Domain (SDNN, RMSSD) の計算
    // ====================================
    function calculateTimeDomainHRV(rrArray) {
      if (rrArray.length < 2) {
        return { sdnn: 0, rmssd: 0 };
      }
      // 平均
      const avg = rrArray.reduce((a, b) => a + b, 0) / rrArray.length;
      // SDNN = RR間隔の標準偏差
      const variance = rrArray.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / rrArray.length;
      const sdnn = Math.sqrt(variance);

      // RMSSD = 連続するRR間隔の差分の二乗平均平方根
      let sumSqDiff = 0;
      for (let i = 1; i < rrArray.length; i++) {
        const diff = rrArray[i] - rrArray[i - 1];
        sumSqDiff += diff * diff;
      }
      const meanSqDiff = sumSqDiff / (rrArray.length - 1);
      const rmssd = Math.sqrt(meanSqDiff);

      return { sdnn, rmssd };
    }

    // ====================================
    // Frequency Domain (LF/HF) の簡易計算
    // ====================================
    // RR間隔配列から LF/HF を計算するためのサンプル関数
    // 実際にはより厳密な処理(窓関数、補間、FFT長、周波数分解能等)が必要です。
    function calculateLFHFRatio(rrArray) {
      // サンプル数が足りない場合は0とする
      if (rrArray.length < 4) {
        return 0;
      }

      // 1. RR間隔(ミリ秒)を秒単位に変換して扱う
      //    → LF, HFの定義上、周波数帯を 0.04-0.15Hz, 0.15-0.4Hz で見ることが多い
      // 2. 不規則サンプリングなので本来は補間が必要だが、ここでは簡易処理として
      //    過去の累積時間を計算した上で等間隔に再サンプリングする。
      const timeStamps = [0];
      for (let i = 1; i < rrArray.length; i++) {
        timeStamps.push(timeStamps[i - 1] + rrArray[i - 1] / 1000.0);
      }

      // 等間隔サンプリングのためのレート(例えば4Hz=250ms間隔)に丸める
      // ※ より精密には全体の平均レートやもっと高い周波数で補間する
      const fs = 4; // サンプルレート(Hz)
      const dt = 1.0 / fs;

      const totalDuration = timeStamps[timeStamps.length - 1];
      const resampledCount = Math.floor(totalDuration * fs);
      if (resampledCount < 4) {
        return 0;
      }

      // 補間による等間隔サンプリング: 線形補間でRR(t)を求める
      // ここでRR(t)というよりは瞬時心拍のような値の方が本来は適切な場合もあるが、
      // サンプルコードとして直接RRをスペクトル解析する
      const resampledRR = [];
      let currentIndex = 0;
      for (let n = 0; n < resampledCount; n++) {
        const t = n * dt;
        // timeStamps[currentIndex] <= t <= timeStamps[currentIndex+1] を探して補間
        while (currentIndex < timeStamps.length - 1 && timeStamps[currentIndex + 1] < t) {
          currentIndex++;
        }
        if (currentIndex >= timeStamps.length - 1) {
          // 末尾を超えたらループ終了
          break;
        }
        const t1 = timeStamps[currentIndex];
        const t2 = timeStamps[currentIndex + 1];
        const rr1 = rrArray[currentIndex];
        const rr2 = rrArray[currentIndex + 1];
        if (t2 === t1) {
          // まれに RR が0などおかしい場合のガード
          resampledRR.push(rr1);
        } else {
          // 線形補間
          const ratio = (t - t1) / (t2 - t1);
          const rrInterp = rr1 + (rr2 - rr1) * ratio;
          resampledRR.push(rrInterp);
        }
      }

      // FFTを実行(ここでは1次元DFTを簡易実装する)-------------------------
      // 本番ではライブラリや高速化したアルゴリズムを使ってください
      const N = resampledRR.length;
      if (N < 4) return 0;

      // 窓関数(ハニングなど)をかける場合はここで適用
      // ...省略(サンプルのため)

      // DFT
      const re = new Array(N).fill(0);
      const im = new Array(N).fill(0);

      for (let k = 0; k < N; k++) {
        for (let n = 0; n < N; n++) {
          const angle = (2 * Math.PI * k * n) / N;
          re[k] += resampledRR[n] * Math.cos(angle);
          im[k] -= resampledRR[n] * Math.sin(angle);
        }
      }

      // スペクトルパワーを計算
      const freqs = [];
      const psd = [];
      for (let k = 0; k < N; k++) {
        // 周波数
        const freq = (k * fs) / N;
        // スペクトルパワー (平方和)
        const magnitude = (re[k] * re[k] + im[k] * im[k]) / N; // /Nは正規化の一例
        freqs.push(freq);
        psd.push(magnitude);
      }

      // LF(0.04-0.15Hz), HF(0.15-0.4Hz) のパワーを積分 (厳密には近似)
      let lfPower = 0;
      let hfPower = 0;
      for (let k = 0; k < N; k++) {
        const f = freqs[k];
        if (f >= 0.04 && f < 0.15) {
          lfPower += psd[k];
        } else if (f >= 0.15 && f < 0.4) {
          hfPower += psd[k];
        }
      }
      // LF/HF を計算
      const lfHfRatio = hfPower === 0 ? 0 : lfPower / hfPower;
      return lfHfRatio;
    }

    // ====================================
    // CSVダウンロード
    // ====================================
    downloadButton.addEventListener('click', () => {
      // ヘッダ行
      let csvContent = '時刻,BPM,SDNN (ms),RMSSD (ms),LF/HF\n';
      dataRecords.forEach(record => {
        csvContent += `${record.time},${record.bpm},${record.sdnn},${record.rmssd},${record.lfHf}\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `PolarH10-HRV-${new Date().toISOString()}.csv`);
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

  </script>
</body>
</html>
