<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Polar Verity Sense Heart Rate Monitor</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #logTable {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    #logTable th, #logTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    #logTable th {
      background-color: #eee;
    }
  </style>
</head>
<body>
  <h1>Polar Verity Sense Heart Rate Monitor</h1>
  <button id="connectButton">デバイスに接続</button>
  <button id="downloadCsvButton" disabled>CSVダウンロード</button>

  <table id="logTable">
    <thead>
      <tr>
        <th>受信時刻</th>
        <th>BPM</th>
        <th>SDNN (ms)</th>
        <th>RMSSD (ms)</th>
      </tr>
    </thead>
    <tbody id="logTbody">
      <!-- ここに最新データを上から順に追加 -->
    </tbody>
  </table>

  <script>
    // RR間隔(ミリ秒)を保持する配列
    let rrIntervals = [];

    // ログを保持する（CSV化用）
    // 形式: [{ timestamp, bpm, sdnn, rmssd }, ...]
    let logData = [];

    document.getElementById('connectButton').addEventListener('click', connectToHeartRateMonitor);
    document.getElementById('downloadCsvButton').addEventListener('click', downloadCsv);

    /**
     * デバイスと接続し、心拍サービスから通知を受け取る
     */
    async function connectToHeartRateMonitor() {
      try {
        // BLE デバイスを検索 (Heart Rate Service = 0x180D)
        const device = await navigator.bluetooth.requestDevice({
          filters: [{ services: ['heart_rate'] }]
        });

        // GATT に接続
        const server = await device.gatt.connect();

        // Heart Rate Service を取得
        const service = await server.getPrimaryService('heart_rate');

        // Heart Rate Measurement Characteristic (0x2A37) を取得
        const characteristic = await service.getCharacteristic('heart_rate_measurement');

        // Notification を受け取るように設定
        await characteristic.startNotifications();

        // イベントリスナーを登録
        characteristic.addEventListener('characteristicvaluechanged', handleHeartRateMeasurement);
        alert('デバイスに接続しました。心拍データの取得を開始します。');

        // CSV ダウンロードボタンを有効化
        document.getElementById('downloadCsvButton').disabled = false;

      } catch (error) {
        console.error(error);
        alert('デバイスとの接続に失敗しました。');
      }
    }

    /**
     * Heart Rate Measurement Characteristic の通知を受け取ったときの処理
     * @param {Event} event
     */
    function handleHeartRateMeasurement(event) {
      const value = event.target.value;
      // DataView からバイトを読み取る
      // 参考: https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.characteristic.heart_rate_measurement.xml
      let flags = value.getUint8(0);
      let index = 1;
      let bpm = 0;

      // 1バイト (8bit) か2バイト (16bit) かチェック
      const is16Bits = flags & 0x01;
      if (is16Bits) {
        bpm = value.getUint16(index, true);
        index += 2;
      } else {
        bpm = value.getUint8(index);
        index += 1;
      }

      // BPM を数値化
      const heartRate = bpm;

      // RR-Interval を含むフラグが立っているかどうか
      const rrIntervalPresent = flags & 0x10;
      let newRRs = [];
      if (rrIntervalPresent) {
        // 残りのデータが RR-Interval (2バイトずつ)
        while (index < value.byteLength) {
          const rrValue = value.getUint16(index, true);
          index += 2;
          // rrValue は単位 1/1024 秒なので、ミリ秒に変換
          const rrMs = (rrValue * 1000) / 1024;
          newRRs.push(rrMs);
          rrIntervals.push(rrMs);
        }
      }

      // SDNN, RMSSD を計算
      const sdnn = computeSdnn(rrIntervals);
      const rmssd = computeRmssd(rrIntervals);

      // ログデータとして管理
      const timeString = new Date().toLocaleTimeString();
      const logEntry = {
        timestamp: timeString,
        bpm: heartRate.toFixed(0),
        sdnn: sdnn.toFixed(2),
        rmssd: rmssd.toFixed(2),
      };
      logData.push(logEntry);

      // 画面に表示 (最新を上に追加)
      prependLogRow(logEntry);
    }

    /**
     * テーブルの先頭に新しい行を追加
     */
    function prependLogRow(logEntry) {
      const logTbody = document.getElementById('logTbody');
      const newRow = document.createElement('tr');

      const timeCell = document.createElement('td');
      timeCell.textContent = logEntry.timestamp;
      newRow.appendChild(timeCell);

      const bpmCell = document.createElement('td');
      bpmCell.textContent = logEntry.bpm;
      newRow.appendChild(bpmCell);

      const sdnnCell = document.createElement('td');
      sdnnCell.textContent = logEntry.sdnn;
      newRow.appendChild(sdnnCell);

      const rmssdCell = document.createElement('td');
      rmssdCell.textContent = logEntry.rmssd;
      newRow.appendChild(rmssdCell);

      // 最新を一番上に表示するため、先頭に挿入
      if (logTbody.firstChild) {
        logTbody.insertBefore(newRow, logTbody.firstChild);
      } else {
        logTbody.appendChild(newRow);
      }
    }

    /**
     * SDNN (RR間隔の標準偏差) を計算 (配列全体を対象)
     * @param {number[]} rrArray - RR間隔配列 (ms)
     * @returns {number}
     */
    function computeSdnn(rrArray) {
      const n = rrArray.length;
      if (n < 2) return 0;

      const mean = rrArray.reduce((acc, val) => acc + val, 0) / n;
      const variance = rrArray.reduce((acc, val) => {
        const diff = val - mean;
        return acc + diff * diff;
      }, 0) / (n - 1);

      return Math.sqrt(variance);
    }

    /**
     * RMSSD (連続したRR間隔の差の2乗平均平方根) を計算 (配列全体を対象)
     * @param {number[]} rrArray - RR間隔配列 (ms)
     * @returns {number}
     */
    function computeRmssd(rrArray) {
      const n = rrArray.length - 1;
      if (n < 1) return 0;

      let sumSq = 0;
      for (let i = 0; i < n; i++) {
        const diff = rrArray[i + 1] - rrArray[i];
        sumSq += diff * diff;
      }

      const meanSq = sumSq / n;
      return Math.sqrt(meanSq);
    }

    /**
     * CSV ダウンロード
     */
    function downloadCsv() {
      if (logData.length === 0) {
        alert('まだデータがありません。');
        return;
      }

      // CSV ヘッダ
      let csvContent = 'Timestamp,BPM,SDNN(ms),RMSSD(ms)\n';

      // データ行
      for (const row of logData) {
        csvContent += `${row.timestamp},${row.bpm},${row.sdnn},${row.rmssd}\n`;
      }

      // Blob を作成
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);

      // ダウンロードリンクを作成してクリック
      const a = document.createElement('a');
      a.href = url;
      a.download = 'heart_rate_data.csv';
      a.click();

      // リソース解放
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
